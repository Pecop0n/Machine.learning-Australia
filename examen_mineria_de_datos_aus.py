# -*- coding: utf-8 -*-
"""Examen mineria de datos AUS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DUgcGmuyczJsYI-G0HUNuU_dDBPI08-N

# **Bussiness Understanding**

#**Informe tecnico - Australia**

Australia revela una diversidad marcada por climas desérticos, semiáridos y tropicales, así como áreas templadas con estaciones distintas. Las regiones más fértiles se encuentran en el sureste y suroeste, mientras que el centro del país es predominantemente árido. Se observa una variabilidad en las precipitaciones, siendo escasas en el interior y más abundantes en las zonas costeras. Aunque Australia es propensa a fenómenos naturales extremos como sequías, inundaciones, ciclones y incendios forestales, su economía se beneficia de la riqueza mineral, destacando como uno de los principales exportadores mundiales de minerales y energéticos.
"""

#importacion de las librerias a utilizar
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import math
from sklearn.metrics import mean_squared_error

#conversor de fechas a data time
from datetime import datetime

# Importaciones para Modelos Supervisados

#Regresionlienal
from sklearn.linear_model import LinearRegression

#train y test
from sklearn.model_selection import train_test_split

#regresion logistica
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report

#Arbol de deciciones de clasificacion
from sklearn.tree import DecisionTreeClassifier

#Arbol de deciciones
from sklearn.tree import DecisionTreeRegressor, plot_tree

#K-meas
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
from sklearn.preprocessing import StandardScaler

#Clustering Jerarquico
from scipy.cluster.hierarchy import dendrogram, linkage
from scipy.cluster.hierarchy import fcluster

#Seleccion de data
from google.colab import files
uploaded = files.upload()
for fn in uploaded.keys():
    name=fn
weatherAUS = pd.read_csv(name, sep=";", on_bad_lines='skip')

"""### **Se realizo una obtencion de datos dentro del programa excel, para mejorar la visualizacion de los datos y su entendimiento**"""

#obtener una baja cantidad de datos, para visualizar la composicion de su matriz
weatherAUS.head()

"""# **Señalar las características y naturaleza claves dentro de los datos para definir los objetivos generales del análisis**"""

#Visualizacion tipos de Datos
weatherAUS.dtypes

# Correlaciones entre variables numéricas
correlaciones = weatherAUS.select_dtypes(include=['float64', 'int64']).corr()
plt.figure(figsize=(12, 10))
sns.heatmap(correlaciones, annot=True, cmap='coolwarm')
plt.title('Correlaciones entre Variables Numéricas')
plt.show()

"""# **Correlacion entre variables target:**
**MaxTemp y Rainfall →** posee una -0.08 ya que al sugiriendo que en los dias con mas calidos tienden a tener una menor precipitacion.

**MaxTemp y Sunshine →** Correlacion positiva de 0.32, indicando que dias con mas horas de sol, tienden a ser mas calidos.

**Rainfall y Sunshine →** Relacion negativa de -0.23, indicadno que dias con mas precipitacion poseen menos horas de sol.

**Cloud9am y Cloud3pm →** Correlacion positiva de 0.60 sugiere que si hay muchas nubes en la mañana, es probable que en la tarde tambien.

**MinTemp y Cloud9am →** Indica una correlacion negativa -0.06, mencionando que la nubosidad de la mañana esta asociada a temperaturas bajas.

# **Identificar la existencia de valores atípicos y valores perdidos, proponiendo rutinas de limpieza que se pueden abordar para generar mayor precisión en los modelos**
"""

#Verificacion de la exitencia de nulos dentro de la data
nulos_existentes = weatherAUS.isnull().any().any()
print("¿Existen datos nulos dentro de la base de datos?", nulos_existentes)

#Visualizacion de los datos nulos existentes
for feature in weatherAUS.columns:
  print("Datos Nulos:", feature, "=", weatherAUS[feature].isna().sum())

"""### **Los siguientes datos, cumplen un rol dentro del target a mencionar tras la preparacion de los datos, por lo cual su falta de datos sera** MaxTemp: 322 - MinTemp: 637 - Rainfall: 1406 - sunshine: 67816 - Cloud9am: 53657 - Cloud3pm: 13981

# **Data Preparation**
"""

#copia del data_frame para el comienzo de la limpieza de datis
weatherAUS_2 = weatherAUS.copy()
weatherAUS_2

"""## **Eliminacion de Outliners**"""

# Identificar lso ouliners existentes
variables_num = weatherAUS_2.select_dtypes(include=['float64', 'int64']).columns

# Calcular el número de filas y columnas necesarias
num_vars = len(variables_num)
num_cols = 3
num_rows = math.ceil(num_vars / num_cols)

# Configurar la figura para los diagramas de caja
plt.figure(figsize=(20, num_rows * 4))  # Ajustar altura de la figura

# Generar diagramas de caja para cada variable numérica
for i, var in enumerate(variables_num):
    plt.subplot(num_rows, num_cols, i + 1)  # Ubicación del subplot
    sns.boxplot(data=weatherAUS_2, x=var)
    plt.title(f'Diagrama de Caja para {var}')

plt.tight_layout()

def eliminar_outliers(df, columna, desviaciones_std=3):
    """
    Elimina los outliers de una columna específica de un DataFrame, basándose en desviaciones estándar.
    Parámetros:
    df (pd.DataFrame): El DataFrame que contiene los datos.
    columna (str): La columna de la que se desean eliminar los outliers.
    desviaciones_std (int, opcional): El número de desviaciones estándar para definir los límites superior e inferior.
                                      El valor por defecto es 3.
    Retorna:
    pd.DataFrame: El DataFrame con los outliers eliminados para la columna especificada.
    """
    # Calcular la media y la desviación estándar de la columna
    media = df[columna].mean()
    desviacion_std = df[columna].std()

    # Definir los límites superior e inferior
    limite_inferior = media - desviaciones_std * desviacion_std
    limite_superior = media + desviaciones_std * desviacion_std

    # Filtrar el DataFrame para eliminar los outliers
    df_filtrado = df[(df[columna] >= limite_inferior) & (df[columna] <= limite_superior)]

    return df_filtrado

# Eliminar outliers en cada variable numérica
for variable in variables_num:
    weatherAUS_2 = eliminar_outliers(weatherAUS_2, variable)

# Identificar variables numéricas en weatherAUS_2
variables_numericas = weatherAUS_2.select_dtypes(include=['float64', 'int64']).columns

# Configurar la figura para los diagramas de caja
num_vars = len(variables_numericas)
num_cols = 3
num_rows = math.ceil(num_vars / num_cols)

plt.figure(figsize=(20, 12))  # Tamaño de la figura
for i, var in enumerate(variables_numericas):
    plt.subplot(num_rows, num_cols, i + 1)  # Ubicación del subplot
    sns.boxplot(data=weatherAUS_2, x=var)
    plt.title(f'Diagrama de Caja para {var}')

plt.tight_layout()
plt.show()

# Imprimir el DataFrame sin outliers
weatherAUS_2.describe()

# Consultar el resultado de la eliminacion de outliners
print("Valores faltantes por procesar:")
print(weatherAUS_2.isnull().sum())

#mostrar los datos perdidos dentro de las tablas en la matriz
missing_data = weatherAUS_2[['WindGustDir', 'WindDir9am', 'WindDir3pm']][weatherAUS_2[['WindGustDir', 'WindDir9am', 'WindDir3pm']].isna().any(axis=1)]
#verificacion visual de la existencia de estos
print(missing_data)

#remplazo de datos nulos a cero
weatherAUS_2.fillna(0, inplace=True)

#nuevo resulatado tras el remplazo de nulos
print("Valores faltantes porprocesar:")
print(weatherAUS_2.isnull().sum())

"""# **Target**

**El objetivo general de esta investigación y análisis es proporcionar una guía integral para la preparación y mitigación de inundaciones en Australia buscando crear un enfoque holístico y colaborativo para enfrentar los desafíos climáticos.**

# **Seleccion de los datos a utilizar para el analisis**

### Se separaran las regiones de australia por su ubicacion geografica **norte_australia, centro_australia, sur_australia** para su agrupacion con los datos de temperatura, sol, lluvia y nubosidad en el dia.
"""

# Convertir la columna 'Date' al formato datetime
weatherAUS_2['Date'] = pd.to_datetime(weatherAUS_2['Date'], format='%d-%m-%Y')

# Extraer el mes de la columna 'Date' en formato MM
weatherAUS_2['Month'] = weatherAUS_2['Date'].dt.strftime('%m')

# Función para asignar la estación según el mes
def asignar_estacion(mes):
    mes = int(mes)
    if mes in [9, 10, 11]:
        return 'Primavera'
    elif mes in [12, 1, 2]:
        return 'Verano'
    elif mes in [3, 4, 5]:
        return 'Otoño'
    elif mes in [6, 7, 8]:
        return 'Invierno'

# Crear la nueva columna 'Estacion'
weatherAUS_2['Estacion'] = weatherAUS_2['Month'].apply(asignar_estacion)

# Definir las regiones del Norte de Australia
norte_australia = [
    'Darwin', 'CoffsHarbour', 'Cairns', 'Albany', 'Broome', 'Perth', 'PearceRAAF', 'Tuggeranong', 'Norfolkisland'
]
# Definir las regiones del Centro de Australia
centro_australia = [
    'AliceSprings', 'Uluru', 'MountGinini', 'Woomera', 'BadgerysCreek', 'Richmond', 'Canberra', 'Witchliffe'
]
# Definir las regiones del Sur de Australia
sur_australia = [
    'Adelaide', 'Launceston', 'MountGambier', 'Melbourne', 'Ballarat', 'Dartmoor', 'Hobart', 'Nuriootpa',
    'Walpole', 'Williamtown', 'Wollongong', 'Mildura', 'Newcastle', 'Sale', 'SalmonGums', 'NorahHead', 'Penrith', 'Portland'
]

# Filtro de datos por las regiones específicas
data_norte = weatherAUS_2[weatherAUS_2['Location'].isin(norte_australia)]
data_centro = weatherAUS_2[weatherAUS_2['Location'].isin(centro_australia)]
data_sur = weatherAUS_2[weatherAUS_2['Location'].isin(sur_australia)]

# Aplicar groupby y calcular el promedio de las variables numéricas (sin 'Month')
grouped_data_norte = data_norte.groupby(['Location', 'Estacion'])[['MinTemp', 'MaxTemp', 'Rainfall', 'Sunshine', 'Cloud9am', 'Cloud3pm']].mean().reset_index()
grouped_data_centro = data_centro.groupby(['Location', 'Estacion'])[['MinTemp', 'MaxTemp', 'Rainfall', 'Sunshine', 'Cloud9am', 'Cloud3pm']].mean().reset_index()
grouped_data_sur = data_sur.groupby(['Location', 'Estacion'])[['MinTemp', 'MaxTemp', 'Rainfall', 'Sunshine', 'Cloud9am', 'Cloud3pm']].mean().reset_index()

# Calcular el valor más frecuente de 'Month' para cada combinación de 'Location' y 'Estacion'
most_frequent_month_norte = data_norte.groupby(['Location', 'Estacion'])['Month'].agg(lambda x: x.mode().iloc[0]).reset_index(name='Month')
most_frequent_month_centro = data_centro.groupby(['Location', 'Estacion'])['Month'].agg(lambda x: x.mode().iloc[0]).reset_index(name='Month')
most_frequent_month_sur = data_sur.groupby(['Location', 'Estacion'])['Month'].agg(lambda x: x.mode().iloc[0]).reset_index(name='Month')

# Unir el valor más frecuente de 'Month' a los DataFrames agrupados
grouped_data_norte = pd.merge(grouped_data_norte, most_frequent_month_norte, on=['Location', 'Estacion'])
grouped_data_centro = pd.merge(grouped_data_centro, most_frequent_month_centro, on=['Location', 'Estacion'])
grouped_data_sur = pd.merge(grouped_data_sur, most_frequent_month_sur, on=['Location', 'Estacion'])

# Generar la matriz de datos
print("Regiones del Norte de Australia:")
print(grouped_data_norte.to_string(index=False))

print("\nRegiones del Centro de Australia:")
print(grouped_data_centro.to_string(index=False))

print("\nRegiones del Sur de Australia:")
print(grouped_data_sur.to_string(index=False))

"""# **Se concadenara los filtros de las regiones de australia anteriormente realizadas**"""

#generar un orden de matriz por zona regional (norte, centro, sur)
Clima_AustraliaRegional = pd.concat([grouped_data_norte, grouped_data_centro, grouped_data_sur])
# Imprime el DataFrame combinado
print(Clima_AustraliaRegional)

#Renombrar los datos para un mejor entendimiento.
Clima_AustraliaRegional.rename(columns={
    'Location': 'Ubicacion',
    'Estacion': 'Estacion',
    'MinTemp': 'Temperatura_Minima',
    'MaxTemp': 'Temperatura_Maxima',
    'Rainfall': 'Lluvia',
    'Sunshine': 'Horas_de_Sol',
    'Cloud9am': 'Nubosidad_9am',
    'Cloud3pm': 'Nubosidad_3pm',
    'Month': 'Mes'
}, inplace=True)

# mostrar el nuevo renombre de la data
print(Clima_AustraliaRegional)

# Guardar los resultados en un nuevo archivo CSV para despues llevarlo a un panel de control
Clima_AustraliaRegional.to_csv('Clima_AustraliaRegional.csv', index=False)

#Composicion de datos de la matriz
Clima_AustraliaRegional.info()

# Correlaciones entre variables numéricas en la nueva matriz
correlaciones = Clima_AustraliaRegional.select_dtypes(include=['float64', 'int64']).corr()
plt.figure(figsize=(12, 10))
sns.heatmap(correlaciones, annot=True, cmap='coolwarm')
plt.title('Correlaciones entre Variables Numéricas')
plt.show()

"""# **Comparacion de matriz de correlacion**

**MaxTemp y Rainfall → Temperatura_maxima y Lluvia** Posee un **aumento de -0.08 a -0.087** La correlación sigue siendo similar, sugiriendo que los días más cálidos tienden a tener una menor precipitación, pero la relación sigue siendo muy débil.

 **MaxTemp y Sunshine → Temperatura_maxima y Horas_de_Sol**: Se genera un **Aumento de la correlacion positiva de 0.32 a un 0.83**, Los datos procesados muestran una correlación positiva mucho más fuerte, indicando que los días con más horas de sol tienden a ser significativamente más cálidos.

**Rainfall y Sunshine → Lluvia y Horas_de_Sol**: Posee Relacion negativa **de -0.25 aumentando a -0.48**, La correlación negativa se intensifica en los datos procesados, lo que sugiere que los días con más precipitación tienen aún menos horas de sol.

**Cloud9am y Cloud3pm → Nubosidad_9am y Nubosidad_3pm:** Correlacion positiva **de 0.60 que se incrementa a un 0.99** La correlación positiva es mucho más fuerte en los datos procesados, sugiriendo que si hay muchas nubes en la mañana, es casi seguro que también habrá muchas nubes en la tarde.

**MinTemp y Cloud9am → Temperatura_Minima y Nubosidad_9am**: Indica una **correlacion negativa -0.06 a -0.31**, La correlación negativa es más pronunciada en los datos procesados, indicando una asociación más fuerte entre la nubosidad de la mañana y temperaturas mínimas más bajas..

# **Sepacion de fechas por estacion**

### **Se generara una matriz de datos las cuales  traera la fecha de los datos y  la estacion en la cual esta fecha sucede**

# **Modelos de entrenamiento**
"""

#copia del data_frame para el comienzo de la limpieza de datis
Weather_AUS_000 = Clima_AustraliaRegional.copy()
Weather_AUS_000

#renombrar el nombres de las estaciones
Weather_AUS_000.Estacion.replace({"Primavera":1, "Verano":2, "Otoño":3, "Invierno":4}, inplace=True)
Weather_AUS_000.head()

# Guardar los resultados en un nuevo archivo CSV para despues llevarlo a un panel de control
Weather_AUS_000.to_csv('weather_aus_000.csv', index=False)

"""# **Modelos Supervisados**

#**Regresion Lineal**
"""

#eliminar una tabla de texto
Weather_AUS_001 = Weather_AUS_000.drop(columns=['Ubicacion'])

#Nuestra Y
Y = Weather_AUS_001["Temperatura_Maxima"]
Y.head()

#Creacion de las variables.

#Nuestra X
X = Weather_AUS_001.drop(["Temperatura_Maxima"], axis=1)
X.head()

X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.33, random_state=42)

Regres_lineal = LinearRegression()
Regres_lineal.fit(X_train, Y_train)
#
print("Forma de X_train:", X_train.shape)
print("Forma de X_test: ", X_test.shape)
print("Forma de y_train:", Y_train.shape)
print("Forma de y_test:", Y_test.shape)

print("Linea de Regresion de train: {:.2%}".format(Regres_lineal.score (X_train, Y_train)))
print("Linea de Regresion de test: {:.2%}". format(Regres_lineal.score(X_test, Y_test)))

"""**Explicacion de los resultado**

*   **95.71%** indica que el modelo se ajusta muy bien a los datos de entrenamiento, ya que casi toda la variabilidad de los datos es capturada por el modelo.
*   **94.59%** indica que el modelo también se ajusta muy bien a los datos de prueba, lo que sugiere que el modelo tiene una buena capacidad de generalización y no está sobreajustado a los datos de entrenamiento.

**lo que quiere decir es que el modelo de regresión lineal que has entrenado tiene un excelente rendimiento tanto en el conjunto de datos de entrenamiento como en el conjunto de datos de prueba. Esto sugiere que el modelo es capaz de capturar la relación entre las características y la variable objetivo de manera efectiva.**




"""

#Prediccion de temperatura maxima por estacion
pred_Y = Regres_lineal.predict(X_test)
sns.scatterplot(x=Y_test, y=pred_Y, color="red")

"""# **Regresión Logística**

**Utilizacion de variable binaria** se retrocede a la base anteriormente limpiada para hacer uso de la variable de binaria **"RainTomorrow"**
"""

weatherAUS_2.RainTomorrow.replace({"Yes":1, "No":2}, inplace=True)
weatherAUS_2.head()

X = weatherAUS_2.drop(['RainTomorrow', 'Date', 'Location', 'WindGustDir', 'WindDir9am', 'WindDir3pm', 'RainToday', 'Estacion'], axis=1, errors='ignore')
y = weatherAUS_2['RainTomorrow']

# División de los datos en conjuntos de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Entrenamiento del modelo
logreg = LogisticRegression()
logreg.fit(X_train, y_train)

# Predicciones
y_pred = logreg.predict(X_test)

# Evaluación del modelo
print(classification_report(y_test, y_pred))

"""*   **Accuracy - Exactitud de los datos:** 0.97 (97%)
*  **Soporte Total:** 13260

**Precision de los datos:**  porcentaje de predicciones positivas correctas.

*   **Llueve:** 95% de las predicciones de que si lluvia son correctas.
*   **No Llueve:** 97% de las predicciones de no llueva son correctas.

**Recall - Sensibilidad de  los datos:** menciona que el porcentaje de **verdaderos positivos** son correctamente identificados.

*   **Llueve:** el 86% de los dias con lluvia (reales positivos) son correctos
*   **No llueve:** el 99% de los dias que no llueve (reales positivos) son correctos.

**F1-Score:** Es la media armónica de la precisión y el recall, ofreciendo un equilibrio entre ambos.

*   **Llueve:** 0.91 indica un buen balance entre precisión y recall para los días con lluvia.
*   **No llueve:** 0.98 indica un excelente balance entre precisión y recall para los días sin lluvia

**Soporte (Support):** Indica el número de ocurrencias de cada clase en los datos de prueba.

*   **Llueve:** 2561
*   **No llueve:** 10699

**El modelo muestra un desempeño excelente con una exactitud del 97%. La alta precisión y recall para ambas clases indican que el modelo es robusto y confiable para predecir si lloverá mañana o no, con un desempeño especialmente fuerte en identificar correctamente los días sin lluvia.**

# **Árbol de Decisión**
"""

# Entrenamiento del modelo
tree_clf = DecisionTreeClassifier()
tree_clf.fit(X_train, y_train)

# Predicciones
y_pred_tree = tree_clf.predict(X_test)

# Evaluación del modelo
print(classification_report(y_test, y_pred_tree))

"""*   **Accuracy - Exactitud de los datos:** 0.97 (97%)
*  **Soporte Total:** 13260

**Precision de los datos:** porcentaje de predicciones positivas correctas.

*   **Llueve:** 92% de las predicciones de lluvia son correctas..
*   **No Llueve:** el 98% de las predicciones de no lluvia son correctas.

**Recall - Sensibilidad de  los datos:** menciona que el porcentaje de **verdaderos positivos** son correctamente identificados.

*   **Llueve:** 92% de los días con lluvia real se identificaron correctamente.
*   **No llueve:** 98% de los días sin lluvia real se identificaron correctamente.

**F1-Score:** Es la media armónica de la precisión y el recall, ofreciendo un equilibrio entre ambos.

*   **Llueve:** 0.92 indica un buen balance entre precisión y recall para los días con lluvia.
*   **No llueve:** 0.98 indica un excelente balance entre precisión y recall para los días sin lluvia.

**Soporte (Support):** Indica el número de ocurrencias de cada clase en los datos de prueba.

*   **Llueve:** 2561
*   **No llueve:** 10699

**El modelo de Árbol de Decisión muestra un desempeño excelente con una exactitud del 97%. Las métricas de precisión, recall y F1-Score son altas para ambas clases, indicando que el modelo es robusto y confiable para predecir si lloverá mañana o no.**

# **Arbol de decision final**
"""

ArbolDecisionesaFinal = Weather_AUS_001[['Estacion', 'Mes', 	'Temperatura_Minima', 'Temperatura_Maxima',	'Lluvia',	'Horas_de_Sol',	'Nubosidad_9am',	'Nubosidad_3pm']]
ArbolDecisionesaFinal

X = ArbolDecisionesaFinal[['Estacion',	'Temperatura_Minima',	'Lluvia',	'Horas_de_Sol',	'Nubosidad_9am',	'Nubosidad_3pm',	'Mes']]
Y = ArbolDecisionesaFinal.Temperatura_Maxima
#Definicion de los train y test para la prueba.
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.33, random_state=42)
Clima_AUS_Regional = DecisionTreeRegressor(max_depth=4, random_state=42)
Clima_AUS_Regional.fit(X_train, Y_train)
Y_pred = Clima_AUS_Regional.predict(X_test)
print("Precicion del modelo Train:", Clima_AUS_Regional.score(X_train, Y_train))
print("Precicion del modelo Test:", Clima_AUS_Regional.score(X_test, Y_test))

"""# **Modelos no surpervisados**

## **K-means**
"""

data = Weather_AUS_001

selected_features = ['Temperatura_Minima', 	'Temperatura_Maxima',  'Lluvia',	'Horas_de_Sol',	'Nubosidad_9am',	'Nubosidad_3pm', 'Mes']

# Eliminar filas con valores nulos
data_selected = data[selected_features].dropna()

# Escalar los datos
scaler = StandardScaler()
data_scaled = scaler.fit_transform(data_selected)

# Determinar el número óptimo de clusters usando el método del codo
sse = []
for k in range(1, 11):
    kmeans = KMeans(n_clusters=k, random_state=42)
    kmeans.fit(data_scaled)
    sse.append(kmeans.inertia_)

# Graficar el método del codo
plt.plot(range(1, 11), sse, marker='o')
plt.xlabel('Número de clusters')
plt.ylabel('SSE')
plt.title('Método del codo')
plt.show()

from sklearn.cluster import KMeans

#número óptimo de clusters es 3
optimal_k = 3
kmeans = KMeans(n_clusters=optimal_k, random_state=42)
clusters = kmeans.fit_predict(data_scaled)

# Añadir los clusters al DataFrame original
data_selected['Temperatura_Minima', 	'Temperatura_Maxima',  'Lluvia',	'Horas_de_Sol',	'Nubosidad_9am',	'Nubosidad_3pm', 'Mes'] = clusters

from sklearn.metrics import silhouette_score

silhouette_avg = silhouette_score(data_scaled, clusters)
print(f"El coeficiente de Silhouette para {optimal_k} clusters es: {silhouette_avg}")

"""El coeficiente de **Silhouette para 3 clusters es de 0.2902,** lo cual indica una coherencia moderada de los clusters formados por el algoritmo K-means.
**¿Porque 3 y no 4?**
Con 4 clusters el coeficiente de Silhouetter **es de 0.2550**. Este valor sugiere que **los clusters formados por el algoritmo K-means son menos coherentes** en comparación con los 3 clusters (0.2902), Si el coeficiente de Silhouette más bajo ** indica que los puntos dentro de los clusters pueden no estar tan bien agrupados y podrían estar cerca de los límites de otros clusters.**

# **Clustering Jerárquico**
"""

# Realizar el clustering jerárquico
linked = linkage(data_scaled, 'ward')

# Graficar el dendrograma
plt.figure(figsize=(10, 7))
dendrogram(linked, truncate_mode='lastp', p=12)
plt.title('Dendrograma del clustering jerárquico')
plt.xlabel('Puntos de datos')
plt.ylabel('Distancia')
plt.show()
plt.show()

"""### **Observacion de diagrama de clustering jerarquico**
**(5,5), (6,6), (4,3), (4,7), (4,3 y (3))**  similutes entre ellos

**((5,5) y (6,6))** altura relativa mente alta pero compatible en similitudes
.....

**(5,5,6,6), ((11,7) y (4,3,3)), ((9,4) y (4,3,3**)) alta distancia mayor disimilitud que las unionen internas.

**Union de ambos grupos** alta distancia entre si, por lo cual ambos grupos son disimiles entre si.

**Resumen:** pese a distanci de unio de los datos, poseen la separacion de los datos similutdes considerables, y ante la ultima union pese poseer una gran altura de diferencia estos siguen poseendo una similitud
"""

# Obtener las etiquetas de los clusters para el clustering jerárquico

cluster_labels_hierarchical = fcluster(linked, t=3, criterion='maxclust')

# Calcular el coeficiente de Silhouette
silhouette_avg_hierarchical = silhouette_score(data_scaled, cluster_labels_hierarchical)
print(f'El coeficiente de Silhouette para el clustering jerárquico es: {silhouette_avg_hierarchical}')

"""# **Utilizacionde el Arbol de regresion**"""

print("Precicion del modelo Train:", Clima_AUS_Regional.score(X_train, Y_train))
print("Precicion del modelo Test:", Clima_AUS_Regional.score(X_test, Y_test))
fig, ax = plt.subplots(figsize=(30, 10))
print(f"Profundidad del arbol de precion es: {Clima_AUS_Regional.get_depth()}")
print(f"EL numero de nodo terminales es: {Clima_AUS_Regional.get_n_leaves()}")
plot = plot_tree(

decision_tree = Clima_AUS_Regional,
feature_names = ArbolDecisionesaFinal.drop(columns=['Mes',]).columns,
class_names = 'Temperatura_Maxima',
filled = True,
impurity = False,
fontsize = 10,
precision = 2,
ax = ax
)



"""## **¿Porque la utilizacion de este modelo?**
**Ayuda a decidir cosas basadas en el clima, como si va a llover mucho y hay riesgo de inundaciones y al poseer un alto porcentajede viabilidad tambien lo hace destacable para precir**



*  **Train:** 0.9824, lo que indica que el modelo tiene una precisión muy alta en los datos de entrenamiento.
*   **Test:** 0.8061, lo que sugiere que el modelo también tiene una buena precisión en los datos de prueba, aunque algo menor que en los datos de entrenamiento.

**Profundidad del árbol de decisión:** 4 esto indica cuántos niveles de decisiones tiene el árbol.

**Número de nodos terminales:** 14 que son los puntos finales del árbol donde se hace una predicción final.

## **Inundaciones en Australia**
Las inundaciones son eventos climaticos significativos en Australia, particular mente en la region este y sur este del pais, ya sea por enfrentarse a lluvias intensas que desbordan rios y sistemas de drenaje, causando grandes daños a propiedades, infractucturas, generar deslizamientos de tierras y perdidas de vida

Las inundaciones son un desastre natural que ocurre principalmente como resultado de la lluvia. **Las regiones más pobladas de Australia, como Nueva Gales del Sur y Victoria, son más vulnerables a las inundaciones porque están situadas cerca de los ríos Murray y Darling, que concentran las precipitaciones en estas zonas**. Sin embargo, no todas las zonas urbanas corren el mismo riesgo de inundaciones, ya que existen diversas medidas aplicadas por diferentes instituciones, incluidas las infraestructuras y la gestión del agua.

**Áreas urbanas:** Pueden ocurrir inundaciones en ciudades como Sydney, Melbourne y Brisbane en ciertos lugares, especialmente aquellos cerca de ríos o con sistemas de drenaje inadecuados.

**Zonas rurales:** Las regiones agrícolas del sureste y suroeste son muy fértiles; sin embargo, también **son susceptibles a condiciones climáticas adversas, como inundaciones, que pueden tener un impacto perjudicial en la producción de cultivos.**

# **Estrategias para Prepararse ante Inundaciones por Lluvia**
**Tras identificar el problema sobre las variaciones en la lluvia y las temperaturas extremas que pueden causar inundaciones y afectar las cosechas.**

###**Mejorar la Gestión del Agua**

*   **Contruccion de presas en areas estrategicas:**Y asi lograr almacenar agua durante las temporadas de lluvias abundantes y utilizarla en épocas de sequía ayudando tambien a regular el flujo de agua y reducir el riesgo de inundaciones.

*   **Sistema de recoleccion de agua:** En comunidades y áreas rurales con concimientos de maneras de aprovechar el agua de lluvia, reduciendo el exceso de agua libre, alacenando estas en container de alto almacenamiento o barriles.

Esto tambien no ayudara a contribuir a reducir el desperdicio de agua en plantaciones, asiendo util el agua almacenada atravez de un riego agoteo generando un riego eficiente.

### **Reforestacion**
**Las temperaturas extremas y la reducción de la nubosidad que pueden afectar la gestión del agua.**

*   **Campaña de reforestacion:** El aumentar la cobertura forestal y mejorar la retención de humedad en el suelo, lo cual ayuda a reducir la escorrentía y el riesgo de inundaciones, el insetivo en comunidades a la plantaciones de arboles nativos asi lograr un entorno mas verde y resiliente.
*   **Proteccion de bosques y talas ilegales:**Atravez de leyes y regulaciones estrictas contra la tala ilegal, manteniendo los bosques que ayudan a absorber el exceso de agua y regular de forma extricta la extracción de recursos sin dañar el ecosistema, manteniendo la capacidad de los bosques para gestionar el agua de lluvia.

### **Fortalecimiento a zonas en areas pobladas con alto indice de riesgo**


*   **Actualizar planes de emergencia:** hacia ventos climáticos extremos como inundaciones, olas de calor e incendios forestale poder aasi capacitar a las comunidades en acciones de emergencia para reaccionar rápidamente ante inundaciones, antes de que estas sucedan.
*   **Mejora de estructuras:** Ya sea puentes, edificios, tapado de goteras, verificar el esto de las carreteras, recorrido de zonas de transito con alto indice de inundacion (zonas bajas, socabones, suelo blando) permitiendo a las comunidades prepararse con antelación, contaste monitoreo de zonas antes y durante los sucesos para actuar rapidamente, disponer de servicios de manera imediata (corte de luz, caida de arbol, vertientes, desbordamiento de rios, etc)

### **Estas estrategias combinan la mejora de la gestión del agua, la reforestación y manejo sostenible de los bosques, y el fortalecimiento de la resiliencia comunitaria para abordar los desafíos climaticos predecibles, eh implementar acciones puede ayudar a mitigar los efectos adversos del clima y mejorar la capacidad de adaptación de las comunidades en Australia, reduciendo el riesgo de inundaciones**
"""